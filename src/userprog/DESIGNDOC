            +----------------------------+
       	    |          CS 450            |
            | PROJECT 2: USER PROGRAMS I |
            |      DESIGN DOCUMENT     	 |
		    +----------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Geoffrey Wright <wrigh2ga@dukes.jmu.edu>

---- PRELIMINARIES ----

Current to this version implementation, PintOS busy-waits for user
processes to get a chance to run. This is known behavior and should
be considered when running this version of the project.

			   ARGUMENT PASSING
			   ================

---- DATA STRUCTURES ----
>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

thread.h:
	struct thread:
		-> struct thread *parent: Points to the parent thread of
		a created kernel thread.

process.c:
	process_execute:
		->const char *args_line: parameter of process_execute function name
		changed to clarify what it is.

		->char *args_copy: variable to hold the copy of args_line, previously
		implemented as fn_copy.

		->char *file_name: re-used name, new variable to hold exclusivly just
		the file name of the runable executable.

		->char *save_ptr: new variable required for the use of strtok_r

	load:
		->char *token: required variable for the use of strtok_r

		->char *save_ptr: required variable for the use of strtok_r

		->char *argv[]: this array hold the token strings from strtok_r
		loop on file_name vector

		->int argc: will represent the number of argument tokens in argv[]

	setup_stack:
		NOTE: FUNCTION PARAMS MODIFIED
			void **esp
			int argc     passed from load
			char *argv[] passed from load

		->uint32_t *argv_addrs[]: the array for the addresses to the argv
		members on the stack.
		
syscall.c:

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

Implimentation updated (10/17/2018):

The logic of where argument passing and how it is happening has changed
slightly.

The implementation of parsing the file_name vector has been moved to
process.c->load(). Inside load the implementation of argument parsing
uses strtok_r() to loop over file_name storing the tokens in and argv
array that is set to PGSIZE size. While no argument line should get
this big the system works in PGSIZE allocations of memory. The assert
later in this explination should still hold to check that the stack
will not overflow a page. If that is a possibility than the assert
will currently panic the kernel and therefore no arguments will be
passed.

In process.c->setup_stack(), which has now been modified to take
the number of arguments and the token argument array, pushing of
arguments to the stack is handled. This is done in by the convention
explained in the PA2 write-up and is separated into code blocks to
show these steps. The process starts underneath the "*esp = PHYS_BASE"
(line 484 process.c) line described in the write up. The decision to do
the process this way was to ensure direct access to the current stack
pointer and address the issue of argument pushing at the point of
the stack being setup. By the naming convention of the function and
by process it made logical sense ot us to adress it here.

Argument actuals are placed in there correct place by offsetting the
stack pointer by the size of items when placing them to the stack.
Other uniform items are placed with the decreasing the pointer by 4
(4 bytes for a 32 bit system) and placing them with the correct casting
for their type (uint32_t for address members and int for null terminal
and numerics).

Currently there is an assertion at the beginning of the argument pushing
section that only allows arguments to be pushed for a user program if it
will not overflow a page to do so. The assert is explained below.

ASSERT((((argc * 2) + 5) * 32) < PGSIZE)
all argv[argc] must store element and address on the stack
+ 5 other required stack elements
* 32 bits for word size.
should be less than the size of a page. 

---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

PintOS implements strtok_r instead of strtok because strtok_r is
reentrant. This means another process can interrupt the current
process duing its call making it's own call to this function without
adversly affecting the original caller. This means that strtok_r
is safe for both interrupt and non-interrupt code to use.

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

1) It allows for up-front error checking on proper names of executables
that exist and proper arguments and options. This minimizes time spent
in the kernel.
2) It assists in cutting down the complexity of kernel code to load and
establish a process.